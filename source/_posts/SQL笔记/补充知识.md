---
title: 补充知识
top_img: 
categories: 
- ETL工程师
- 拓展
tags:
- 补充知识
---

# on与where的区别

1.在内连接即`inner join`中==没有区别==，

2.在使用`left jion`时，`on`和`where`条件的区别如下：
1、on条件是==在生成临时表时使用的条件==，它不管on中的条件是否为真，都会返回左边表中的记录。
2、where条件是==在临时表生成好后，再对临时表进行过滤的条件==。这时已经没有`left join`的含义（必须返回左边表的记录）了，条件不为真的就全部过滤掉。



# ROWNUM

1.只能从1开始



# 删除表内重复数据







# PLSQL中的字符串

### 1.在使用execute immediate时

```plsql
 v_sql := 'select * from emp where ename='||''''||v_ename||'''';
```

> 此时需要额外添加单引号，因为这是字符串类型（执行时需要有引号）。

### 2.在使用select语句时

```plsql
select * into v_temp from emp where ename=v_ename;
```

> 此时不需要加单引号，程序可以判断出变量为字符串类型。



# PLSQL立刻执行(EXECUTE IMMEDIATE)问题

```plsql
BEGIN 
	EXECUTE IMMEDIATE 'create table stt(a number)'; 
	INSERT INTO stt VALUES(1); 
	COMMIT; 
END; 
这条语句， 为什么会报错 表stt找不到呢？不是先执行建表语句了吗？
```

> 答：
>
> ddl在pl-sql块里必须动态执行，
>
> 同时也影响依赖它的sql必须动态执行，
>
> 同时它还会自动提交之前的事务。  少用为妙。

将代码改为如下：

```plsql
EXECUTE IMMEDIATE 'create table stt(a number)';
EXECUTE IMMEDIATE 'INSERT INTO stt VALUES(1)';
commit;
```



# &提示符

&弹窗输入 可以替换所有地方，本质和你直接写代码没有区别

==相当于弹出输入框让你输入代码==



# commit在块中/dml在块中

> 在块中使用dml语句时，提交也放在块中



