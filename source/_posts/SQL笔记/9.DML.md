---
title: DML语句
top_img: 
categories: 
- ETL工程师
- SQL基础
tags:
- DML
---

# Oracle中的语句

一、 DQL 语句
DQL（Data Query Language）语句：数据查询语言，主要是对数据进行查询操作。
常用关键字有 SELECT、FROM、WHERE 等。

二、 DDL 语句
DDL（Data Definition Language）语句： 数据定义语言，主要是进行定义/改变表的结构、数据类型、表之间的链接等操作。
常用的语句关键字有 CREATE、DROP、ALTER 等。

三、 DML 语句
DML（Data Manipulation Language）语句: 数据操纵语言，主要是对数据进行增加、删除、修改操作。
常用的语句关键字有 INSERT、DELETE、 UPDATE 等。

四、 DCL 语句
DCL（Data Control Language）语句： 数据控制语言，主要是用来设置/更改数据库用户权限。
常用关键字有 GRANT、REVOKE 等。

# DML语句 数据操纵语言

## 一.INSERT 插入

### 1.插入整行数据

```sql
INSERT INTO 表名 VALUES(值1,值2,值...);
SELECT * FROM AAA;
```

插入字符型数据

```sql
INSERT INTO AAA VALUES(ZHUYUXUAN);--报错

INSERT INTO AAA VALUES('ZHUYUXUAN');
```

可以插入相同的数据

```sql
INSERT INTO AAA VALUES('DUHAO','HUANGYINGZHENG');--报错，当插入的值超过列数时，值过多，列数得保持一致

INSERT INTO EMP VALUES('DUHAO','HUANGYINGZHENG');--报错，当插入的值少于列数时，没有足够的值，列数得保持一致
```

插入数值型数据

```sql
DROP TABLE AAA;
TRUNCATE TABLE AAA;
ALTER TABLE AAA MODIFY (ENAME NUMBER(20));
SELECT * FROM AAA;
INSERT INTO AAA VALUES('ABC');--报错，已经修改成了数值型
INSERT INTO AAA VALUES('123');--隐式转换
INSERT INTO AAA VALUES(123);
INSERT INTO AAA VALUES(TO_DATE('1996-12-30','YYYY-MM-DD'));--不可以
```

插入日期型数据

```sql
VARCHAR2(20)--20指的是
SELECT LENGTHB(SYSDATE) FROM DUAL;
SELECT LENGTHB(TO_DATE('1996-12-30 16:10:00','YYYY-MM-DD HH24:MI:SS')) FROM DUAL;
--日期型的字节长度为11位
```

以下为拓展内容

```sql
INSERT INTO AAA VALUES('123');--可以插入字符串

INSERT INTO AAA VALUES(123);--数值型可以变成字符型，是什么类型的直接写成什么类型

INSERT INTO AAA VALUES(SYSDATE+1);--日期型可以变成字符型

ALTER TABLE AAA MODIFY (ENAME VARCHAR2(20));--修改数据类型

INSERT INTO AAA VALUES(TO_DATE('1996-12-30','YYYY-MM-DD'));--可以写函数
```




### 2.插入部分行数据

**（插入一行内部分数据）**

语法：

```sql
INSERT INTO 表名(字段1,字段2,...) VALUES(值1,值2,...)
```



```sql
例如：INSERT INTO EMP_2(CNAME,ENGLISH) VALUES('可钦',90);
```

--没有插入值的地方以空值填充

```sql
INSERT INTO EMP_2(CNAME,ENGLISH) VALUES('',100);
INSERT INTO EMP_2(CNAME,ENGLISH) VALUES(NULL,100);
```

--空值可以为两个单引号，中间不写内容，也可以为NULL

```sql
COMMIT;--提交，在上一次提交之后做的操作都被提交掉
ROLLBACK;--回滚，在上一次提交之后做的操作都被回滚掉
```

--DDL语句默认运行提交，会把在上一次提交之后做的操作都被提交掉

```sql
alter TABLE EMP_2 ADD(SEX CHAR(10));
```

### 3.从来源表插入数据

语法：

```sql
INSERT INTO 表名（字段1，字段2） SELECT 字段1,字段2 FROM 数据来源表 <WHERE>
```

前面写插入到哪些列里面去，后面写插入哪些列的内容



- 如果有多个满足条件的会全部插入，如果没有where会把内容全部插入
- 如果插入的数据长度大于被插入的列，会报错，需要修改被插入的列的数据类型



## 二.UPDATE 更新表

`FOR UPDATE` 更新表语句

语法： 

```sql
UPDATE 表名 SET 字段1=新值1,字段2=新值2,...<WHERE>
```



例如：

```sql
UPDATE EMP_2 SET CHINESE = 100 WHERE CNO = 1;
UPDATE EMP_2 SET CHINESE = 100 WHERE CNO = 7499;
--加了WHERE限制条件，符合条件的才会被修改

UPDATE EMP_2 SET CNO = 100 WHERE MATHS = 100;
--修改的内容在SET后面 WHERE 前面

UPDATE EMP_2 SET CNO = 100;
--不加WHERE限制条件，列内所有的都会被修改

SELECT * FROM EMP_2;
```



## 三.DELETE 删除

--只能删除数据，不能删除表

语法：`DELETE FROM` 表名 `WHERE` 条件;

```SQL
DELETE FROM EMP_2 WHERE CNAME = '沉渊' OR CNO IN(1,2,3);
--符合条件的都被会删掉

DELETE FROM EMP_2;
--如果DELETE 没有WHERE条件，相当于没有COMMIT的TRUNCATE
```





事务在处理过程中遇到错误时，点击确定或帮助，会跳过错误，继续执行，直到遇到下一个错误或者结束。

点击取消或者叉掉，直接结束运行，没有报错的部分会被执行。



## 四.事务



**使用一系列语句构成的逻辑工作单元**



`COMMIT` --提交
`ROLLBACK` --回滚
`SAVEPOINT` 保存点名 --保存点

思考题：`COMMIT`和`SAVEPOINT`连用会怎么样呢？

```sql
SELECT * FROM EMP_2;
INSERT INTO EMP_2 (CNO) VALUES (5);
INSERT INTO EMP_2 (CNO) VALUES (6);
SAVEPOINT A ;
INSERT INTO EMP_2 (CNO) VALUES (7);
INSERT INTO EMP_2 (CNO) VALUES (8);
ROLLBACK TO SAVEPOINT A;
ROLLBACK;

--1.保存点后面必须写名字；
--2.ROLLBACK TO SAVEPOINT 保存点名，会回滚到保存点，保存点之前的操作会留下（不是提交），保存点到rollback之间的内容会被回滚掉，
--3.ROLLBACK会把保存点回滚掉

SELECT * FROM EMP3;
删除表内全部数据
方法一：TRUNCATE TABLE EMP3;

方法二：DELETE FROM EMP3 ;
COMMIT;

删除列：
ALTER TABLE EMP3 DROP COLUMN EMPNO;
ALTER TABLE EMP3 DROP (JOB,HIREDATE,SAL,COMM,DEPTNO);

INSERT INTO EMP3 VALUES(1234);
INSERT INTO EMP3 VALUES(2234);
INSERT INTO EMP3 VALUES(3234);
INSERT INTO EMP3 VALUES(44234);
INSERT INTO EMP3 VALUES(1234);
INSERT INTO EMP3 VALUES(2234);
```

--事务在处理过程中遇到错误时，点击确定或帮助，会跳过错误，继续执行，直到遇到下一个错误或者结束
--点击取消或者叉掉，直接结束运行，没有报错的部分会被执行



### 事务的四个属性：

- [x] **原子性**

  事务是一个整体的工作单元，要么全部提交，要么全部回滚；

- [x] **一致性**

  所有数据必须保持状态一致，以保持数据的完整性；

  (事务执行成功时，所有数据会变为新状态，执行失败则所有数据变为事务开始前的状态)

- [x] **隔离性**

  当前事务进行数据修改时，只要还没提交，其他事务只能查看修改前的状态；
  (以后可能很多人同时使用一个数据库，只要没提交，别人就看不到新状态(新数据))

- [x] **持久性**

  事务提交后，修改的内容会被永久保存。





> 显式提交 DML
> 隐式提交 DDL
